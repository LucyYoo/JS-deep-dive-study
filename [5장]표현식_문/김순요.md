# 5장 표현식과 문

## 값

- 값(value)은 **표현식(expression)이 평가(evaluate)되어 생성된 결과**를 말한다.

```jsx
// 10 + 20 은 평가되어 숫자 값 30을 생성한다.
10 + 20

// 10 + 20이 평가되어 30이란 값이 변수에 할당된다.
var score = 10 + 20
```

## 리터럴

- 리터럴(literal)은 **사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**(notation)을 말한다.

```jsx
// 숫자 리터럴 3
3
```

**위 예제의 3은 단순한 아라비아 숫자가 아니라 `숫자 리터럴` 이다. 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 코드에 기술하면 자바스크립트 엔진은 이를 `평가` 해 숫자 값 3을 생성한다.**

- 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 미리 약속된 기호( ‘ ‘, “ ”, . , [ ], { }, // 등) 로 표기한 코드가 곧 리터럴
- 자바스크립트 엔진은 코드가 실행되는 `런타임` 시점에 리터럴을 `평가`해 값을 생성한다.
- 즉 리터럴은 **값을 생성하기 위해 미리 약속한 표기법**이라 할 수 있다.

리터럴을 통해 생성할 수 있는 값의 종류는 `p52` 자료 참고

## 표현식

- **표현식(expression)은 값으로 평가될 수 있는 문(statement)**이다. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
  - 리터럴도 값으로 평가되므로 리터럴 역시 표현식이다.

```jsx
var score = 50 + 50; // 50 + 50이 평가되어 100이라는 값을 생성하므로 50 + 50은 표현식

score; // 변수 score 식별자는 값을 참조하여 변수 값으로 평가되므로 표현식 

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수, 메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

- 표현식과 표현식이 평가된 값은 동등한 관계, 즉 **동치(equivalant)**다.

  - ex) `1+2` 와 `3` 은 동치다.

  - 따라서 표현식은 값처럼 사용할 수 있으며 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다.

  - 예를 들어, 좌항과 우항에 숫자 값이 위치해야 하는 `+` 연산자의 경우

    - 숫자 값으로 평가될 수 있는 표현식 또한 좌항과 우항에 위치할 수 있다.

    ```jsx
    var x = 1 + 2; // x는 1 + 2 표현식과 3이라는 값과 동치이며, 3이라는 값으로 평가된다.
    
    // 식별자 표현식 x는 3으로 평가된다.
    x + 3; // x + 3 표현식은 6이라는 값으로 평가된다.
    ```

## 문

- 문(statement)은 **프로그램을 구성하는 기본 단위이자 최소 실행 단위**

- 문의 집합이 곧 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍

- 문은 여러 **토큰(Token)**으로 구성된다.

  - **토큰(Token)**이란 **문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미**한다.
  - example) 키워드, 식별자, 연산자, 리터럴, 세미콜론(;), 마침표(.) 등

  ```jsx
  var score = 1 + 2;
  /*
  Token
  -> var, score, =, 1, +, 2, ; 
  */
  ```

- 문은 다른 말로 **명령문이라고도** 부른다. 컴퓨터에 내리는 명령을 의미하며, 문이 실행되면 명령이 실행되어 어떤 일이 발생하게 된다.

- 문은 **선언문, 할당문, 조건문, 반복문** 등으로 구분할 수 있다.

```jsx
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if(x > 1){ console.log(x); }

// 반복문
for(var i = 0; i < 2; i++){ console.log(i); }
```

## 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론(;)은 문의 종료를 의미
- 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행
- 단, i**f문, for문, 함수** 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다. **코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문.**
- 자바스크립트에서는 문의 끝에 세미콜론을 붙이지 않아도 **세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)**이 암묵적으로 수행된다.

> **세미콜론 자동 삽입 기능(ASI)**
>
> 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 기능

- **그러나 ASI와 개발자의 예측이 일치하지 않는 경우도 있다.**

```jsx
function foo(){
	return
			{} 
	/*
	개발자의 예측 => return {};
	ASI의 예측 => return; {};
*/
}

var bar = function(){}
(function(){})();
/*
 개발자의 동작 결과 => var bar = function(){}; (function(){})();
ASI의 동작 결과 => var bar = function(){} (function(){})();

// 결과
TypeError: (immediate value)(...) is not a function

*/
```

- 세미콜론을 반드시 붙여야 한다는 주장이 대다수이지만, 붙이지 말아야 한다는 주장도 있다.
- **ESLint와 같은 정적 분석 도구에서도 세미콜론 사용을 기본으로 설정하는 등 대부분 세미콜론 사용을 권장하는 분위기**

## 표현식인 문과 표현식이 아닌 문

- 표현식은 문의 일부일 수도 있고, 그 자체로 문이 될 수도 있다.

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;

// 표현식이면서 완전한 문(할당문)이다.
x = 1 + 2;
```

- 표현식과 문을 구별하는 방법
  - **값으로 평가될 수 있는 문 → 표현식인 문**
  - **값으로 평가될 수 없는 문 → 표현식이 아닌 문**
  - **문을 변수에 할당해보면 표현식인 문은 값으로 평가되므로 에러가 발생하지 않지만, 표현식이 아닌 문은 값으로 평가될 수 없으므로 에러가 발생한다.**

```jsx
var foo = var x; // Error, var x는 표현식이 아닌 선언문이다.

var x;  // 선언문, 표현식 아님
x = 100; // 할당문, 표현식이면서 완전한 문
var foo = x = 100; // 표현식인 문은 값처럼 사용 가능
```

> **완료 값(completion value)**
>
> 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 완료값이라고 한다. 완료 값은 표현식의 평가 결과가 아니다. 따라서 변수에 할당할 수도 없고 참조할 수도 없다**.** 반면에 표현식인 문을 실행하면 언제나 평가된 값을 반환한다.
>
> ![Untitled (1)](김순요.assets/Untitled (1)-16703942410363.png)